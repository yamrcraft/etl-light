
spark {
  app-name = "kafka-etl"
  config {
    // Apache Spark configurations
    spark.executor.memory = "1g"
    spark.eventLog.enabled = "false"
    spark.ui.port = "4045"
  }
}

kafka {
  // list of topics to consume
  topics = ["events"]

  // Kafka configurations
  config {
    group.id = "kafka-etl"
    metadata.broker.list = "kafka:9092"
    auto.offset.reset = "smallest"
  }
}

etl {

  // distributed lock, use it to control concurrent runs.
  lock {
    enabled = false
    zookeeper-connect = "locahost:2181"
    path = "/etl/file.lock"
    wait-for-lock-seconds = 10
  }

  state {
    folder = "file:///root/etl/work/state"
    files-to-keep = 20
  }

  errors-folder = "file:///root/etl/errors/events"

  //max-num-of-output-files = 1

  pipeline {

    factory-class = "yamrcraft.etlight.pipeline.JsonPipelineFactory"

    transformer = {
      config = {
        timestamp-field = "ts"
        timestamp-field-format = "yyyy-MM-dd HH:mm:ss"

        default-schema-file = "file:///user/spark/etl/events.avsc"

        schema-selection {
          field = "event_type"
          schemas {
            users = "file:///user/spark/etl/users.avsc"
            clicks = "file:///user/spark/etl/clicks.avsc"
          }
        }
      }
    }

    writer = {
      config = {
        // uses local file-system file to append data during processing
        working-folder = "file:///root/etl/work/events"

        // final destination folder - file will be copied from working-folder to output-folder on commit.
        output-folder = "file:///root/etl/output/events"

        // output folder structure (according to time retrieved from input event as specified by transformer.timestamp-field)
        partition {
          pattern = "YYYY/MM/dd/HH"
        }

        // mapping of record name (e.g. Avro record name) to folder name.
        record-name-to-folder-mapping {
          Users = "users_events"
          Clicks = "clicks_events"
        }
      }
    }
  }

}
